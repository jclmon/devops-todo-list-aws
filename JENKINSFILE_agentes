pipeline {

    agent none
    
    //no descarga el codigo fuente en todos los agentes
    options{ skipDefaultCheckout() }
    
    stages {
        stage('Get Code') {
			agent { label 'python' }
			steps {
				showInfo()
				cleanWs()				
				git branch: 'develop', url: 'https://github.com/jclmon/devops-todo-list-aws.git'
				sh '''curl -o samconfig.toml https://raw.githubusercontent.com/jclmon/devops-todo-list-aws-config/staging/samconfig.toml'''
				stash name:'code', includes:'**'
				stash name: 'samconfig', includes:'samconfig.toml'
			}
		}
		stage('Static Test') {
            agent { label 'python' }
            steps {
				showInfo()
				unstash 'code'
				
				// Ejecuto flake8 analisis estatico
				sh '/home/ubuntu/.local/bin/flake8 --exit-zero --format=pylint src > result-flake8.out'
				recordIssues enabledForFailure: true, tools: [ flake8(name: 'Flake8', pattern: 'result-flake8.out') ], qualityGates: [[threshold: 0, type: 'TOTAL', criticality: 'FAILURE']]
				
				// Ejecuto Bandit analisis de seguridad
				sh '/home/ubuntu/.local/bin/bandit  -r src -f custom -o bandit.out --msg-template "{abspath}:{line}: [{test_id}] {msg}" || true'
				recordIssues tools: [pyLint(name: 'Bandit', pattern: 'bandit.out')], qualityGates: [[threshold: 0, type: 'TOTAL', unstable: false]]
            }
        }		 
		stage('Deploy') {
			agent { label 'built-in' }
            steps {
				showInfo()
				unstash 'code'
				unstash 'samconfig'
				
				sh """
					echo "=== Verificando credenciales AWS ==="
					aws sts get-caller-identity
					
					sam build --template template.yaml
				"""
										
				// Despliegue simplificado ahora que las credenciales están configuradas
				sh """
					export SAM_CLI_TELEMETRY=0
					
					echo "=== Desplegando con SAM ==="
					sam deploy --config-file samconfig.toml --config-env staging --resolve-s3 --no-fail-on-empty-changeset --no-confirm-changeset
					
					echo "=== Deploy completado exitosamente ==="
				"""
				
				// sh """
				// 	sam validate --template template.yaml
				// """
					
				// Obtener BaseUrlApi y guardar en archivo
				sh """
					aws cloudformation describe-stacks \\
						--stack-name todo-list-aws-staging \\
						--query 'Stacks[0].Outputs[?OutputKey==`BaseUrlApi`].OutputValue' \\
						--output text \\
						--region us-east-1 > base_url.txt
					echo "BaseUrlApi guardada en base_url.txt"
					cat base_url.txt
				"""
				// Guardar el archivo en stash
				stash name: 'base_url', includes: 'base_url.txt'
            }
        }
		stage('Rest') {
			agent { label 'python' }
			steps {
				showInfo()
				unstash 'code'
				unstash 'base_url'		
				
				// Espera a que el servicio responda antes de continuar
				script {
					env.BASE_URL = sh(script: "cat base_url.txt", returnStdout: true).trim()
					waitForServiceAvailability("${env.BASE_URL}/todos", "API TodoList")
				}
				sh """
					export PATH=\$PATH:/home/ubuntu/.local/bin
					export BASE_URL=\$(cat base_url.txt)
					echo "BASE_URL: \${BASE_URL}"
												
					echo 'Verificando pytest'
					which pytest || pip3 install pytest
					
					echo 'Verificando estructura de tests'
					ls -la test/integration/
					
					echo 'Ejecutando tests de integración'
					pytest -v test/integration/todoApiTest.py --junitxml=result-rest.xml || {
						echo "=== Tests fallaron, revisando logs de Lambda ==="
						aws logs tail /aws/lambda/todo-list-aws-staging-CreateTodoFunction --region us-east-1 --since 5m || true
						exit 1
					}
				"""
				junit skipPublishingChecks: true, testResults: 'result-rest.xml'
			}
		}
		stage('Promote') {
			agent { label 'python' }
			steps {
				showInfo()
				
				withCredentials([usernamePassword(credentialsId: 'github-credentials', usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
					sh """
						echo "=== Promoviendo versión a Release ==="
						
						# Configurar git con tu usuario
						git config user.email "jclmon@outlook.es"
						git config user.name "jclmon"
						
						# Verificar rama actual
						echo "Rama actual: \$(git branch --show-current)"
						
						# Hacer fetch de todas las ramas
						git fetch origin
						
						# Checkout a master
						git checkout master
						
						# Merge de develop a master
						echo "Mergeando develop en master..."
					git merge origin/develop -m "Merge develop to master - Release version \$(date +%Y%m%d-%H%M%S)" || {
						echo "Conflicto detectado, resolviendo..."
						# Si hay conflicto en JENKINSFILE, usar versión de master
						git checkout --ours JENKINSFILE
						git add JENKINSFILE
						# Si hay conflicto en JENKINSFILE_agentes, usar versión de master
						git checkout --ours JENKINSFILE_agentes
						git add JENKINSFILE_agentes
						# Verificar si hay otros conflictos
						if git diff --name-only --diff-filter=U | grep -v JENKINSFILE; then
							echo "ERROR: Hay otros conflictos además de JENKINSFILE"
							git merge --abort
							exit 1
						fi
						# Completar el merge
						git commit -m "Merge develop to master - Release version \$(date +%Y%m%d-%H%M%S)"
					}
						echo "=== Versión promovida exitosamente a master ==="
					"""
				}				
				script {
					echo "=== Disparando pipeline de producción CD ==="
					build job: 'todo-list-aws-production-agentes', 
						wait: false,
						parameters: [
							string(name: 'BRANCH', value: 'master')
						]
					echo "=== Pipeline CD de producción iniciado ==="
				}
			}
		}
    }
    post {
        always {
            node('built-in') {
                cleanWs()
            }
            node('python') {
                cleanWs()
            }
        }
    }
}

def showInfo() {    
	def envInfo = sh(script: '''
        echo "Whoami: $(whoami)"
        echo "Hostname: $(hostname)"
        echo "WORKSPACE: ${WORKSPACE}"
    ''', returnStdout: true).trim()
}

def waitForServiceAvailability(url, serviceName) {
    echo "Esperando a ${serviceName} en ${url}..."
    timeout(time: 30, unit: 'SECONDS') {
        waitUntil {
            try {
                def response = sh(
                    script: "curl -s -o /dev/null -w '%{http_code}' --connect-timeout 2 --max-time 5 '${url}'", 
                    returnStdout: true
                ).trim()                
                return (response == '200')
            } catch (Exception e) {
                return false
            }
        }
    }
    echo "${serviceName} está disponible."
}